<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Arqueiro Lend√°rio</title>
  <style>
    body {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      margin: 0;
      overflow: hidden;
      color: white;
      font-family: 'Arial', sans-serif;
      text-align: center;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    
    canvas {
      display: none;
      background: #111;
      margin: 20px auto;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    #menu {
      background: rgba(0, 0, 0, 0.7);
      padding: 30px;
      border-radius: 15px;
      max-width: 600px;
      margin: 0 auto;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
      border: 2px solid #4CAF50;
    }
    
    h1 {
      color: #4CAF50;
      text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
      margin-bottom: 30px;
      font-size: 2.5em;
    }
    
    .power-options {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .power-option {
      background: rgba(30, 30, 46, 0.8);
      padding: 15px;
      border-radius: 10px;
      width: 150px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
    }
    
    .power-option:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      border-color: #4CAF50;
    }
    
    .power-option.selected {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.2);
    }
    
    .power-option img {
      width: 60px;
      height: 60px;
      margin-bottom: 10px;
    }
    
    button {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 1.2em;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-top: 20px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
      background: linear-gradient(135deg, #45a049, #1B5E20);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    #victory-screen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    
    #victory-screen h1 {
      color: gold;
      font-size: 4em;
      text-shadow: 0 0 20px gold;
      margin-bottom: 30px;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .power-description {
      font-size: 0.9em;
      color: #aaa;
      margin-top: 5px;
    }
    
    #wave-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 1.2em;
      border: 1px solid #4CAF50;
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>Arqueiro √âpico</h1>
    <div class="power-options">
      <div class="power-option selected" onclick="selectPower('explosive')">
       <div class="character-icon">üí£</div>
        <div>Explosivo</div>
        <div class="power-description">Explode em volta de si dando dano em √°rea</div>
      </div>
      <div class="power-option" onclick="selectPower('multi')">
        <div class="character-icon">üèπ</div>
        <div>M√∫ltiplos tiros</div>
        <div class="power-description">Dispara 5 flechas de uma vez</div>
      </div>
      <div class="power-option" onclick="selectPower('freeze')">
        <div class="character-icon">ü•∂</div>
        <div>Congelante</div>
        <div class="power-description">Congela os inimigos e os desacelera por um per√≠odo de tempo</div>
      </div>
      <div class="power-option" onclick="selectPower('lightning')">
       <div class="character-icon">üå©Ô∏è</div>
        <div>Rel√¢mpago</div>
        <div class="power-description">Eletrocuta os inimigos, dando dano em cadeia mas diminuindo o dano</div>
      </div>
      <div class="power-option" onclick="selectPower('shield')">
        <div class="character-icon">üõ°Ô∏è</div>
        <div>Escudo</div>
        <div class="power-description">Ganha um escudo de invencibilidade tempor√°ria</div>
      </div>
    </div>
    <button onclick="startGame()">Come√ßar Jogo</button>
  </div>
  
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  
  <div id="wave-display" style="display: none;">Wave: 1</div>
  
  <div id="victory-screen">
    <h1>VIT√ìRIA!</h1>
    <p>Voc√™ derrotou todos os inimigos e se tornou o Arqueiro Lend√°rio!</p>
    <button onclick="backToMenu()">Testar Outros Poderes</button>
  </div>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const waveDisplay = document.getElementById('wave-display');
    const victoryScreen = document.getElementById('victory-screen');

    let keys = {}, mouse = { x: 0, y: 0, clicked: false };
    let selectedSpecial = 'explosive';
    let gameActive = false;

    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', () => mouse.clicked = true);
    canvas.addEventListener('mouseup', () => mouse.clicked = false);

    function selectPower(power) {
      selectedSpecial = power;
      document.querySelectorAll('.power-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      event.currentTarget.classList.add('selected');
    }

    function startGame() {
      document.getElementById('menu').style.display = 'none';
      canvas.style.display = 'block';
      waveDisplay.style.display = 'block';
      gameActive = true;
      init();
    }

    function backToMenu() {
      victoryScreen.style.display = 'none';
      document.getElementById('menu').style.display = 'block';
      canvas.style.display = 'none';
      waveDisplay.style.display = 'none';
      gameActive = false;
    }

    class Player {
      constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.speed = 4;
        this.radius = 20;
        this.health = 100;
        this.maxHealth = 100;
        this.shootCooldown = 0;
        this.specialCooldown = 0;
        this.shieldActive = false;
        this.shieldTimer = 0;
        this.slowTimer = 0;
        this.originalSpeed = this.speed;
      }

      update() {
        // Aplica slow se necess√°rio
        if (this.slowTimer > 0) {
          this.slowTimer--;
          this.speed = this.originalSpeed * 0.5;
        } else {
          this.speed = this.originalSpeed;
        }

        if (keys["KeyW"]) this.y -= this.speed;
        if (keys["KeyS"]) this.y += this.speed;
        if (keys["KeyA"]) this.x -= this.speed;
        if (keys["KeyD"]) this.x += this.speed;
        this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));

        if (mouse.clicked && this.shootCooldown <= 0) {
          const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
          arrows.push(new Arrow(this.x, this.y, angle));
          this.shootCooldown = 15;
        }

        if (this.shootCooldown > 0) this.shootCooldown--;
        if (this.specialCooldown > 0) this.specialCooldown--;

        if (keys["KeyE"] && this.specialCooldown <= 0) {
          useSpecial(this);
          this.specialCooldown = 600;
        }

        if (this.shieldActive) {
          this.shieldTimer--;
          if (this.shieldTimer <= 0) {
            this.shieldActive = false;
          }
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        const angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
        ctx.rotate(angle);
        
        // Desenha escudo se ativo
        if (this.shieldActive) {
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)';
          ctx.lineWidth = 3;
          ctx.stroke();
        }
        
        // Corpo do jogador
        ctx.fillStyle = "#4CAF50";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Arco
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(0, -5, 30, 10);
        
        // Detalhes
        ctx.fillStyle = "#45a049";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius - 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
    }

    class Arrow {
      constructor(x, y, angle, specialEffect = null) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 8;
        this.dx = Math.cos(angle) * this.speed;
        this.dy = Math.sin(angle) * this.speed;
        this.alive = true;
        this.specialEffect = specialEffect;
        this.lifetime = 100;
      }

      update() {
        this.x += this.dx;
        this.y += this.dy;
        this.lifetime--;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.lifetime <= 0) {
          this.alive = false;
        }
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (this.specialEffect === 'lightning') {
          ctx.fillStyle = "gold";
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(20, 0);
          ctx.stroke();
          
          // Efeito de rel√¢mpago
          for (let i = 0; i < 5; i++) {
            const offset = Math.random() * 4 - 2;
            ctx.beginPath();
            ctx.moveTo(i * 4, offset);
            ctx.lineTo((i + 1) * 4, offset + (Math.random() * 4 - 2));
            ctx.strokeStyle = "cyan";
            ctx.stroke();
          }
        } else {
          ctx.fillStyle = this.specialEffect ? "gold" : "white";
          ctx.fillRect(0, -2, 20, 4);
        }
        
        ctx.restore();
      }
    }

    // Tipos de inimigos:
    // 1 - B√°sico (fraco)
    // 2 - Resistente (mais vida)
    // 3 - R√°pido (veloz)
    // 4 - Tanque (muita vida, lento)
    // 5 - Atirador (ataca √† dist√¢ncia)
    // 6 - Boss normal (wave 5)
    // 7 - Boss intermedi√°rio (wave 10)
    // 8 - Boss final (wave 15)

    class Enemy {
      constructor(type = 1, wave = 1) {
        this.type = type;
        this.wave = wave;
        
        // Posi√ß√£o inicial aleat√≥ria nas bordas
        if (Math.random() < 0.5) {
          this.x = Math.random() < 0.5 ? 0 : canvas.width;
          this.y = Math.random() * canvas.height;
        } else {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() < 0.5 ? 0 : canvas.height;
        }
        
        // Ajusta atributos baseados no tipo
        switch(type) {
          case 1: // B√°sico
            this.radius = 15;
            this.speed = 2 + wave * 0.05;
            this.health = 30 + wave * 2;
            this.color = "red";
            this.damage = 0.3;
            break;
          case 2: // Resistente
            this.radius = 20;
            this.speed = 1.5 + wave * 0.03;
            this.health = 80 + wave * 4;
            this.color = "darkred";
            this.damage = 0.5;
            break;
          case 3: // R√°pido
            this.radius = 12;
            this.speed = 3.5 + wave * 0.07;
            this.health = 20 + wave * 1.5;
            this.color = "orange";
            this.damage = 0.2;
            break;
          case 4: // Tanque
            this.radius = 25;
            this.speed = 1 + wave * 0.02;
            this.health = 150 + wave * 8;
            this.color = "brown";
            this.damage = 0.8;
            break;
          case 5: // Atirador
            this.radius = 18;
            this.speed = 1.8 + wave * 0.04;
            this.health = 50 + wave * 3;
            this.color = "purple";
            this.damage = 0.4;
            this.shootCooldown = 0;
            break;
          case 6: // Boss wave 5
            this.radius = 40;
            this.speed = player.speed * 0.8; // 80% da velocidade do jogador
            this.health = 400 + wave * 30;
            this.color = "darkviolet";
            this.damage = 1.5;
            this.shootCooldown = 0;
            this.fireTrailCooldown = 0;
            this.fireTrails = [];
            break;
          case 7: // Boss wave 10
            this.radius = 40;
            this.speed = player.speed * 0.95; // 95% da velocidade do jogador
            this.health = (400 + wave * 30) * 1.3; // 30% mais vida que o boss da wave 5
            this.color = "yellow";
            this.damage = 1.5;
            this.shootCooldown = 0;
            this.specialCooldown = 0;
            break;
          case 8: // Boss final wave 15
            this.radius = 60; // Um pouco maior
            this.speed = player.speed * 0.8; // 80% da velocidade do jogador
            this.health = (400 + wave * 30) * 1.6; // 60% mais vida que o boss da wave 5
            this.color = "orange";
            this.damage = 2;
            this.shootCooldown = 0;
            this.minionCooldown = 0;
            this.phase = 1;
            this.auraActive = false;
            break;
        }
        
        this.maxHealth = this.health;
        this.originalSpeed = this.speed;
      }

      update() {
        // Movimento diferente para atiradores e bosses
        if (this.type === 5 || this.type === 6 || this.type === 7 || this.type === 8) {
          // Todos os bosses agora se movem em dire√ß√£o ao jogador
          const angle = Math.atan2(player.y - this.y, player.x - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
          
          // Comportamento espec√≠fico para cada tipo de boss
          if (this.type === 6) { // Boss wave 5 - Rastro de fogo
            this.fireTrailCooldown--;
            if (this.fireTrailCooldown <= 0) {
              this.fireTrails.push(new FireTrail(this.x, this.y));
              this.fireTrailCooldown = 60; // 1 segundo
            }
            
            // Atira no jogador mais r√°pido
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle, this.type));
              this.shootCooldown = 45; // Cooldown menor para atirar mais r√°pido
            }
          }
          else if (this.type === 7) { // Boss wave 10 - Tiros em leque e esferas de energia
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              // Dispara 3 tiros em leque
              for (let i = -1; i <= 1; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle + (i * 0.3), this.type));
              }
              this.shootCooldown = 90;
            }
            
            // Esferas de energia a cada 5 segundos
            this.specialCooldown--;
            if (this.specialCooldown <= 0) {
              for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle, 'energy'));
              }
              this.specialCooldown = 300; // 5 segundos
            }
          }
          else if (this.type === 8) { // Boss final - Minions e fase 2
            // Fase 2 quando chega a 50% de vida
            if (this.health < this.maxHealth / 2 && this.phase === 1) {
              this.phase = 2;
              this.color = "red";
              this.damage *= 1.4; // 40% mais dano
              this.auraActive = true;
            }
            
            // Spawn de minions
            this.minionCooldown--;
            const minionInterval = this.phase === 1 ? 240 : 150; // 4s ou 2.5s
            if (this.minionCooldown <= 0) {
              enemies.push(new Enemy(1, this.wave + 5)); // Minion mais forte que inimigo normal
              this.minionCooldown = minionInterval;
            }
            
            // Ataques
            if (this.shootCooldown <= 0) {
              const shootAngle = Math.atan2(player.y - this.y, player.x - this.x);
              // Padr√£o de tiro especial
              for (let i = 0; i < 8; i++) {
                enemyProjectiles.push(new EnemyProjectile(this.x, this.y, shootAngle + (i * Math.PI / 4), this.type));
              }
              this.shootCooldown = 60; // Cooldown menor
            }
          }
          
          if (this.shootCooldown > 0) this.shootCooldown--;
        } else {
          // Movimento padr√£o em dire√ß√£o ao jogador para inimigos normais
          const angle = Math.atan2(player.y - this.y, player.x - this.x);
          this.x += Math.cos(angle) * this.speed;
          this.y += Math.sin(angle) * this.speed;
        }
      }

      draw() {
        // Corpo do inimigo
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Detalhes baseados no tipo
        switch(this.type) {
          case 2: // Resistente
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius - 5, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 3: // R√°pido
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
            break;
          case 4: // Tanque
            ctx.fillStyle = "darkgray";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius - 5, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 5: // Atirador
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 6: // Boss wave 5
          case 7: // Boss wave 10
          case 8: // Boss final
            // Olhos
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(angle);
            
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(10, -5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(10, 5, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Barra de vida
            ctx.fillStyle = "white";
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, this.radius * 2, 5);
            ctx.fillStyle = "red";
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 15, this.radius * 2 * (this.health / this.maxHealth), 5);
            
            // Texto do boss
            ctx.fillStyle = "white";
            ctx.font = "16px Arial";
            if (this.type === 6) {
              ctx.fillText("BOSS", this.x - 20, this.y - this.radius - 25);
            } else if (this.type === 7) {
              ctx.fillText("BOSS AMARELO", this.x - 50, this.y - this.radius - 25);
            } else if (this.type === 8) {
              ctx.fillText("BOSS FINAL", this.x - 40, this.y - this.radius - 25);
              
              // Aura vermelha na fase 2
              if (this.auraActive) {
                ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 15, 0, Math.PI * 2);
                ctx.stroke();
              }
            }
            break;
        }
        
        // Desenha rastro de fogo do boss wave 5
        if (this.type === 6) {
          this.fireTrails = this.fireTrails.filter(trail => trail.lifetime > 0);
          this.fireTrails.forEach(trail => {
            trail.update();
            trail.draw();
          });
        }
      }
    }

    class FireTrail {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 20;
        this.lifetime = 120; // 2 segundos
      }
      
      update() {
        this.lifetime--;
      }
      
      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
        gradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Colis√£o com jogador
        if (Math.hypot(player.x - this.x, player.y - this.y) < player.radius + this.radius) {
          if (!player.shieldActive) {
            player.health -= 0.5; // Dano cont√≠nuo
          }
        }
      }
    }

    class EnemyProjectile {
      constructor(x, y, angle, enemyType) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.enemyType = enemyType;
        
        if (enemyType === 'energy') {
          this.speed = 3;
          this.damage = 20;
          this.radius = 8;
          this.color = "cyan";
          this.isEnergyBall = true;
        } else {
          this.speed = enemyType === 7 ? 5 : enemyType === 6 ? 6 : 4;
          this.damage = enemyType === 7 ? 7 : enemyType === 6 ? 10 : 5;
          this.radius = enemyType === 7 ? 6 : enemyType === 6 ? 8 : 5;
          this.color = enemyType === 7 ? "yellow" : enemyType === 6 ? "purple" : "orange";
          this.isEnergyBall = false;
        }
        
        this.alive = true;
      }

      update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
          this.alive = false;
        }
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        if (this.isEnergyBall) {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    class PowerUp {
      constructor(type = null) {
        this.x = Math.random() * (canvas.width - 100) + 50;
        this.y = Math.random() * (canvas.height - 100) + 50;
        this.radius = 15;
        this.type = type || (Math.random() < 0.5 ? "heal" : 
                   Math.random() < 0.7 ? "rapid" : 
                   Math.random() < 0.85 ? "special" : 
                   Math.random() < 0.9 ? "shield" : "maxhp");
        this.lifetime = 600; // 10 segundos
      }

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Fundo
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // √çcone
        switch(this.type) {
          case "heal":
            ctx.fillStyle = "lime";
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(7, 7);
            ctx.lineTo(-7, 7);
            ctx.closePath();
            ctx.fill();
            break;
          case "rapid":
            ctx.fillStyle = "cyan";
            ctx.fillRect(-8, -3, 16, 6);
            ctx.fillRect(-3, -8, 6, 16);
            break;
          case "special":
            ctx.fillStyle = "gold";
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            break;
          case "shield":
            ctx.strokeStyle = "rgba(0, 150, 255, 0.8)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.stroke();
            break;
          case "maxhp":
            ctx.fillStyle = "pink";
            ctx.beginPath();
            ctx.arc(0, -5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(-5, -2, 10, 10);
            break;
        }
        
        ctx.restore();
        
        this.lifetime--;
        if (this.lifetime <= 0) this.alive = false;
      }
    }

    function useSpecial(player) {
      const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      
      switch(selectedSpecial) {
        case "explosive":
          // Explos√£o que causa dano em √°rea
          explosions.push(new Explosion(player.x, player.y, 100));
          enemies.forEach(e => {
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            if (dist < 100) e.health -= 50 + (dist < 50 ? 30 : 0);
          });
          bosses.forEach(b => {
            const dist = Math.hypot(player.x - b.x, player.y - b.y);
            if (dist < 100) b.health -= 30 + (dist < 50 ? 20 : 0);
          });
          break;
          
        case "multi":
          // Dispara m√∫ltiplas flechas
          for (let i = -2; i <= 2; i++) {
            arrows.push(new Arrow(player.x, player.y, angle + i * 0.15));
          }
          break;
          
        case "freeze":
          // Congela inimigos temporariamente
          enemies.forEach(e => {
            e.speed *= 0.2;
            setTimeout(() => e.speed = e.originalSpeed, 5000);
          });
          bosses.forEach(b => {
            b.speed *= 0.5;
            setTimeout(() => b.speed = b.originalSpeed, 3000);
          });
          freezeEffects.push(new FreezeEffect(player.x, player.y));
          break;
          
        case "lightning":
          // Rel√¢mpago que salta entre inimigos
          const lightningTargets = [...enemies, ...bosses].filter(e => 
            Math.hypot(player.x - e.x, player.y - e.y) < 200
          ).sort((a, b) => 
            Math.hypot(player.x - a.x, player.y - a.y) - Math.hypot(player.x - b.x, player.y - b.y)
          ).slice(0, 5);
          
          if (lightningTargets.length > 0) {
            lightningEffects.push(new LightningEffect(player, lightningTargets));
            
            lightningTargets.forEach((target, i) => {
              target.health -= 40 / (i + 1);
              if (target.type === 5 || target.type === 6 || target.type === 7 || target.type === 8) {
                target.shootCooldown += 60; // Atiradores e bosses ficam atordoados
              }
            });
          }
          break;
          
        case "shield":
          // Escudo protetor
          player.shieldActive = true;
          player.shieldTimer = 300; // 5 segundos
          break;
      }
    }

    class Explosion {
      constructor(x, y, radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.maxRadius = radius;
        this.lifetime = 30;
      }
      
      update() {
        this.lifetime--;
        this.radius = this.maxRadius * (this.lifetime / 30);
      }
      
      draw() {
        const gradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.radius
        );
        gradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
        gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class FreezeEffect {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 200;
        this.lifetime = 60;
      }
      
      update() {
        this.lifetime--;
      }
      
      draw() {
        ctx.strokeStyle = `rgba(0, 200, 255, ${this.lifetime / 60})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    class LightningEffect {
      constructor(source, targets) {
        this.source = source;
        this.targets = targets;
        this.lifetime = 10;
      }
      
      draw() {
        if (this.lifetime <= 0) return;
        this.lifetime--;
        
        ctx.strokeStyle = `rgba(0, 200, 255, ${this.lifetime / 10})`;
        ctx.lineWidth = 2;
        
        let lastX = this.source.x;
        let lastY = this.source.y;
        
        for (const target of this.targets) {
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          
          // Cria um efeito de rel√¢mpago irregular
          const steps = 5;
          const dx = (target.x - lastX) / steps;
          const dy = (target.y - lastY) / steps;
          
          for (let i = 1; i <= steps; i++) {
            const x = lastX + dx * i + (Math.random() * 10 - 5);
            const y = lastY + dy * i + (Math.random() * 10 - 5);
            ctx.lineTo(x, y);
          }
          
          ctx.stroke();
          lastX = target.x;
          lastY = target.y;
        }
      }
    }

    function drawHUD() {
      // Barra de vida
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(20, 20, 200, 30);
      ctx.fillStyle = player.health > 50 ? "lime" : player.health > 20 ? "orange" : "red";
      ctx.fillRect(20, 20, 200 * (player.health / player.maxHealth), 30);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 20, 200, 30);
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.fillText(`Vida: ${Math.floor(player.health)}/${player.maxHealth}`, 30, 42);
      
      // Barra de especial
      const specialWidth = 200 * (1 - player.specialCooldown / 600);
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(20, 60, 200, 20);
      ctx.fillStyle = specialWidth >= 200 ? "gold" : "rgba(200, 200, 0, 0.7)";
      ctx.fillRect(20, 60, specialWidth, 20);
      ctx.strokeStyle = "white";
      ctx.strokeRect(20, 60, 200, 20);
      
      if (specialWidth >= 200) {
        ctx.fillStyle = "black";
        ctx.fillText("ESPECIAL PRONTO (E)", 30, 76);
      }
      
      // Poder selecionado
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      let specialName = "";
      switch(selectedSpecial) {
        case "explosive": specialName = "Explosivo"; break;
        case "multi": specialName = "M√∫ltiplos Tiros"; break;
        case "freeze": specialName = "Congelante"; break;
        case "lightning": specialName = "Rel√¢mpago"; break;
        case "shield": specialName = "Escudo"; break;
      }
      ctx.fillText(`Poder: ${specialName}`, 20, 100);
      
      // Escudo ativo
      if (player.shieldActive) {
        ctx.fillStyle = "rgba(0, 150, 255, 0.7)";
        ctx.fillText(`Escudo: ${Math.ceil(player.shieldTimer / 60)}s`, 20, 130);
      }
      
      // Slow ativo
      if (player.slowTimer > 0) {
        ctx.fillStyle = "rgba(0, 200, 255, 0.7)";
        ctx.fillText(`Slow: ${Math.ceil(player.slowTimer / 60)}s`, 20, 160);
      }
    }

    function spawnEnemiesForWave(wave) {
      const count = 5 + wave * 2;
      const bossWave = wave % 5 === 0;
      const finalBossWave = wave === 15;
      
      // Limpa inimigos existentes
      enemies = [];
      
      if (finalBossWave) {
        // Wave do boss final
        bosses.push(new Enemy(8, wave));
        waveDisplay.textContent = `Wave: ${wave} (BOSS FINAL)`;
      } else if (bossWave) {
        if (wave === 5) {
          // Wave 5 - Boss normal (mais dif√≠cil)
          bosses.push(new Enemy(6, wave));
          waveDisplay.textContent = `Wave: ${wave} (BOSS)`;
        } else if (wave === 10) {
          // Wave 10 - Boss amarelo
          bosses.push(new Enemy(7, wave));
          waveDisplay.textContent = `Wave: ${wave} (BOSS AMARELO)`;
        } else {
          // Outras waves de boss (caso adicione mais)
          bosses.push(new Enemy(6, wave));
          waveDisplay.textContent = `Wave: ${wave} (BOSS)`;
        }
      } else {
        // Wave normal
        for (let i = 0; i < count; i++) {
          // Escolhe tipo de inimigo baseado na wave
          let type;
          const r = Math.random();
          
          if (wave < 3) {
            type = 1; // Apenas b√°sicos nas waves iniciais
          } else if (wave < 6) {
            type = r < 0.7 ? 1 : r < 0.9 ? 2 : 3;
          } else if (wave < 10) {
            type = r < 0.5 ? 1 : r < 0.75 ? 2 : r < 0.9 ? 3 : 4;
          } else {
            type = r < 0.4 ? 1 : r < 0.65 ? 2 : r < 0.8 ? 3 : r < 0.9 ? 4 : 5;
          }
          
          enemies.push(new Enemy(type, wave));
        }
        waveDisplay.textContent = `Wave: ${wave}`;
      }
      
      // Chance de spawnar power-up
      if (Math.random() < 0.3) {
        powerUps.push(new PowerUp());
      }
    }

    function showWaveStart(wave) {
      const waveText = wave === 15 ? "BOSS FINAL" : 
                      wave === 10 ? "BOSS AMARELO" : 
                      wave === 5 ? "BOSS INCOMING" : 
                      `WAVE ${wave}`;
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(canvas.width / 2 - 150, canvas.height / 2 - 50, 300, 100);
      ctx.strokeStyle = "gold";
      ctx.lineWidth = 3;
      ctx.strokeRect(canvas.width / 2 - 150, canvas.height / 2 - 50, 300, 100);
      ctx.fillStyle = "white";
      ctx.font = "36px Arial";
      ctx.textAlign = "center";
      ctx.fillText(waveText, canvas.width / 2, canvas.height / 2);
      ctx.font = "18px Arial";
      ctx.fillText("Prepare-se!", canvas.width / 2, canvas.height / 2 + 30);
      ctx.textAlign = "start";
    }

    let player, arrows, enemies, bosses, powerUps, enemyProjectiles;
    let explosions, freezeEffects, lightningEffects;
    let currentWave, waveTimer, gameOver;

    function init() {
      player = new Player();
      arrows = [];
      enemies = [];
      bosses = [];
      powerUps = [];
      enemyProjectiles = [];
      explosions = [];
      freezeEffects = [];
      lightningEffects = [];
      
      currentWave = 1;
      waveTimer = 180; 
      gameOver = false;
      
      spawnEnemiesForWave(currentWave);
      requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
      if (!gameActive) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Fundo estrelado
      ctx.fillStyle = "white";
      for (let i = 0; i < 100; i++) {
        const alpha = Math.random() * 0.8 + 0.2;
        const size = Math.random() * 2 + 1;
        ctx.globalAlpha = alpha;
        ctx.fillRect(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          size, size
        );
      }
      ctx.globalAlpha = 1;

      if (player.health <= 0) {
        gameOver = true;
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "red";
        ctx.font = "48px Arial";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 30);
        ctx.font = "24px Arial";
        ctx.fillText(`Voc√™ chegou at√© a wave ${currentWave}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillStyle = "white";
        ctx.fillText("Clique para voltar ao menu", canvas.width / 2, canvas.height / 2 + 60);
        ctx.textAlign = "start";
        
        canvas.addEventListener('click', backToMenu, { once: true });
        return;
      }

      // Mostra aviso de wave no in√≠cio
      if (waveTimer > 0) {
        waveTimer--;
        showWaveStart(currentWave);
        
        // N√£o atualiza o jogo durante o aviso
        requestAnimationFrame(gameLoop);
        return;
      }

      player.update();
      player.draw();

      // Atualiza e desenha flechas
      arrows = arrows.filter(a => a.alive);
      arrows.forEach(a => { a.update(); a.draw(); });

      // Atualiza e desenha inimigos
      enemies.forEach(e => {
        e.update();
        e.draw();
        
        // Colis√£o com jogador
        if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius) {
          if (!player.shieldActive) {
            player.health -= e.damage;
          }
        }
      });

      // Atualiza e desenha bosses
      bosses.forEach(b => {
        b.update();
        b.draw();
        
        // Colis√£o com jogador
        if (Math.hypot(player.x - b.x, player.y - b.y) < player.radius + b.radius) {
          if (!player.shieldActive) {
            player.health -= b.damage;
          }
        }
      });

      // Atualiza e desenha proj√©teis inimigos
      enemyProjectiles = enemyProjectiles.filter(p => p.alive);
      enemyProjectiles.forEach(p => {
        p.update();
        p.draw();
        
        // Colis√£o com jogador
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          if (!player.shieldActive) {
            player.health -= p.damage;
            if (p.isEnergyBall) {
              player.slowTimer = 60; // 1 segundo de slow
            }
          }
          p.alive = false;
        }
      });

      // Atualiza e desenha power-ups
      powerUps = powerUps.filter(p => p.lifetime > 0);
      powerUps.forEach((p, i) => {
        p.draw();
        
        // Colis√£o com jogador
        if (Math.hypot(player.x - p.x, player.y - p.y) < player.radius + p.radius) {
          switch(p.type) {
            case "heal":
              player.health = Math.min(player.maxHealth, player.health + 30);
              break;
            case "rapid":
              player.shootCooldown = Math.max(0, player.shootCooldown - 60);
              break;
            case "special":
              player.specialCooldown = Math.max(0, player.specialCooldown - 120);
              break;
            case "shield":
              player.shieldActive = true;
              player.shieldTimer = 300;
              break;
            case "maxhp":
              player.maxHealth += 20;
              player.health += 20;
              break;
          }
          powerUps.splice(i, 1);
        }
      });

      // Colis√£o de flechas com inimigos
      arrows.forEach(a => {
        enemies.forEach(e => {
          if (Math.hypot(a.x - e.x, a.y - e.y) < e.radius) {
            e.health -= a.specialEffect === 'lightning' ? 40 : 25;
            a.alive = false;
          }
        });
        
        bosses.forEach(b => {
          if (Math.hypot(a.x - b.x, a.y - b.y) < b.radius) {
            b.health -= a.specialEffect === 'lightning' ? 30 : 15;
            a.alive = false;
          }
        });
      });

      // Filtra inimigos e bosses mortos
      enemies = enemies.filter(e => e.health > 0);
      bosses = bosses.filter(b => b.health > 0);

      // Atualiza efeitos especiais
      explosions = explosions.filter(e => e.lifetime > 0);
      explosions.forEach(e => { e.update(); e.draw(); });
      
      freezeEffects = freezeEffects.filter(f => f.lifetime > 0);
      freezeEffects.forEach(f => { f.update(); f.draw(); });
      
      lightningEffects = lightningEffects.filter(l => l.lifetime > 0);
      lightningEffects.forEach(l => l.draw());

      // Verifica se a wave foi completada
      if (enemies.length === 0 && bosses.length === 0 && waveTimer <= 0) {
        currentWave++;
        
        // Verifica vit√≥ria
        if (currentWave > 15) {
          victoryScreen.style.display = 'flex';
          return;
        }
        
        waveTimer = 180; // 3 segundos entre waves
        spawnEnemiesForWave(currentWave);
      }

      drawHUD();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
